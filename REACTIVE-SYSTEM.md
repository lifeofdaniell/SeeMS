# Reactive CMS System - Production Guide

## Overview

The system now uses Vue's reactive template syntax (`{{ content.field }}`) instead of DOM manipulation. This is
production-ready, SSR-compatible, and fully integrated with the converter.

## How It Works

### Production Mode (Normal Visitors)

1. **Server-Side Rendering (SSR)**
    - Nuxt fetches content from Strapi during SSR
    - Page renders with actual content on server
    - HTML sent to browser with content already populated
    - Perfect for SEO and performance

2. **Client-Side Hydration**
    - Vue hydrates the page
    - Content remains reactive
    - If Strapi content updates, refresh shows new content

### Preview/Edit Mode (`?preview=true`)

1. **Initial Load**
    - Page fetches content from Strapi (SSR + client)
    - Content populates global reactive state
    - Editor overlay loads
    - If drafts exist in IndexedDB, they override Strapi content

2. **Editing**
    - User clicks element → contentEditable
    - On blur → Updates reactive state immediately
    - Vue automatically re-renders the UI
    - Debounced save to IndexedDB (300ms)

3. **Publishing**
    - Drafts sent to Strapi API
    - Content updated in Strapi
    - User can exit preview mode to see published content

## Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                    Vue Component (Page)                     │
│  <template>                                                 │
│    <h1>{{ content.hero_heading }}</h1>  ← Reactive binding  │
│  </template>                                                │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ↓ Uses
┌─────────────────────────────────────────────────────────────┐
│         useStrapiContent('pageName') Composable             │
│                                                             │
│  Normal Mode:     strapiData → content                      │
│  Preview Mode:    editorState → content                     │
└────────┬──────────────────────────────┬─────────────────────┘
         │                              │
         ↓ Fetches                      ↓ Reads/Writes
┌─────────────────┐           ┌──────────────────────────┐
│  Strapi v5 API  │           │  Global Editor State     │
│  /api/pagename  │           │  (reactive object)       │
└─────────────────┘           └──────────┬───────────────┘
                                         │
                                         ↓ Accessed by
                              ┌──────────────────────────┐
                              │   Editor Overlay Package │
                              │   (updates on edit)      │
                              └──────────────────────────┘
```

## Key Files

### Nuxt Project (Generated by Converter)

1. **`composables/useEditorContent.ts`**
    - Global reactive state for editor
    - Tracks changes per page
    - Exposed via `window.__editorState` for editor overlay

2. **`composables/useStrapiContent.ts`**
    - Fetches from Strapi (SSR + client)
    - Initializes editor state with Strapi content
    - Returns reactive `content` object
    - Switches between Strapi and editor state based on preview mode

3. **`pages/*.vue`**
    - Uses `{{ content.fieldName }}` template syntax
    - Images use `:src="content.image"`
    - Rich text uses `v-html="content.richField"`
    - Collections use `v-for="item in content.collection"`

### Converter Package

1. **`vue-transformer.ts`**
    - Transforms static HTML to reactive templates
    - Replaces text with `{{ content.field }}`
    - Adds `:src` bindings for images
    - Converts repeated items to `v-for` loops

2. **`editor-integration.ts`**
    - Generates `useEditorContent.ts` composable
    - Generates `useStrapiContent.ts` composable
    - Creates server endpoints for save/publish

3. **`converter.ts`**
    - Step 1-7: Generate static Vue files
    - Step 8: Analyze and generate manifest
    - **Step 8.5: Transform to reactive templates** ✨
    - Step 9+: Generate schemas, seed data, etc.

### Editor Overlay Package

1. **`editor.ts`**
    - Finds editable elements via manifest
    - On edit: Updates `window.__editorState` → Vue re-renders
    - Saves drafts to IndexedDB
    - Loads drafts and populates reactive state

## Fixes Applied

### Bug 1: Preview Mode Shows Blank Page

**Problem:** Initial load in preview mode didn't populate editor state
**Fix:** Always initialize from Strapi (drafts override later)

**Before:**

```typescript
if (newData && !editorContent.isPreviewMode.value) {
    editorContent.initializePageContent(pageName, newData);
}
```

**After:**

```typescript
if (newData) {
    // Always initialize from Strapi on first load
    // Drafts will override this when they load in the editor
    editorContent.initializePageContent(pageName, newData);
}
```

### Bug 2: No SSR in Production

**Problem:** `server: false` disabled server-side rendering
**Fix:** Removed SSR opt-out, now works with SSR

**Before:**

```typescript
useFetch(url, {
    lazy: true,
    server: false, // ❌ Breaks SSR
})
```

**After:**

```typescript
useFetch(url, {
    key: `strapi-${pageName}`, // ✅ SSR-friendly
    transform: (response) => response?.data || response,
})
```

### Bug 3: Drafts Don't Update UI

**Problem:** Loading drafts only updated DOM, not reactive state
**Fix:** Update reactive state when loading drafts

**Before:**

```typescript
function applyDraft(fields: Record<string, any>): void {
    editableElements.forEach((data) => {
        data.element.textContent = value; // ❌ DOM only
    });
}
```

**After:**

```typescript
function applyDraft(fields: Record<string, any>): void {
    // Update reactive state for all draft fields
    Object.entries(fields).forEach(([fieldName, value]) => {
        updateReactiveState(fieldName, value); // ✅ Vue reactive
    });
    // ... track element changes
}
```

## Converter Integration

### When You Run the Converter

```bash
pnpm convert
```

The converter now:

1. ✅ Converts HTML to Vue files (static)
2. ✅ Generates CMS manifest
3. ✅ **Transforms Vue files to reactive templates**
4. ✅ Generates `useEditorContent.ts`
5. ✅ Generates `useStrapiContent.ts`
6. ✅ Generates server API endpoints
7. ✅ Generates Strapi schemas
8. ✅ Generates seed data

All future projects will be automatically generated with reactive templates!

### Existing Projects

For the existing `nuxt-dev` project, we've already transformed all pages to use reactive templates.

## Production Deployment Checklist

- ✅ Pages use `{{ content.field }}` syntax
- ✅ SSR enabled (no `server: false`)
- ✅ Content fetches from Strapi on server
- ✅ Editor state initializes from Strapi
- ✅ Drafts override initial content in preview mode
- ✅ Publishing updates Strapi
- ✅ Normal visitors see published content
- ✅ SEO-friendly (content in HTML)
- ✅ Fast initial load (SSR)

## Testing

### Test Production Mode

```bash
cd nuxt-dev
pnpm build
pnpm preview
# Visit http://localhost:3000
# Should show Strapi content with SSR
```

### Test Preview Mode

```bash
# Visit http://localhost:3000?preview=true
# Should:
# 1. Show Strapi content initially
# 2. Load drafts from IndexedDB
# 3. Allow editing
# 4. Update UI instantly on blur
# 5. Save drafts
# 6. Publish to Strapi
```

## Benefits

1. **Vue-Idiomatic**: Uses template syntax, not DOM manipulation
2. **SSR-Compatible**: Works with server-side rendering
3. **Reactive**: Instant UI updates via Vue's reactivity
4. **Type-Safe**: Content objects are reactive refs
5. **Performance**: Virtual DOM optimizations
6. **SEO-Friendly**: Content rendered on server
7. **Maintainable**: Standard Vue patterns
8. **Production-Ready**: Fully tested and integrated

## Migration Notes

The system automatically handles:

- Converting static HTML → reactive templates
- Generating composables
- Setting up editor integration
- Creating API endpoints

No manual migration needed for new projects!
